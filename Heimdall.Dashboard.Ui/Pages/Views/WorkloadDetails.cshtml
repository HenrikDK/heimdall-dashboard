<template id="workload-details">
  <div class="pl-2 pr-4 max-w-5xl mx-auto">

    <div class="flex mt-4 mb-6 text-xl items-center text-gray-500 dark:text-gray-300 font-light sans h-8">
      <div class="text-md">
      <router-link class="hover:text-sky-500 dark:hover:text-blue-400" :to="{ name: 'workloads' }"> {{item.kind}} </router-link> / 
      <router-link class="hover:text-sky-500 dark:hover:text-blue-400" :to="{ name: 'workloads-redirect', params: {namespace: item?.metadata?.namespace } }"> {{item?.metadata?.namespace }} </router-link> / 
      {{ item?.metadata?.name }}
      </div>
    </div>
    
    <workload-charts :charts="charts" :config="config"></workload-charts>

    <workload-info :item="item" :config="config"></workload-info>

    <workload-pods :pods="pods" :metrics="metrics"></workload-pods>

    <workload-events :events="events"></workload-events>

    <br/><br/><br/><br/>
    
  </div>
</template>

<script type="module">
import { useDark } from "@@vueuse/core";
import { ref, onMounted, onUnmounted, watch } from 'vue'
import { useRoute } from 'vue-router';

let setup = (props, ctx) => {
  const isDark = useDark();
  const item = ref({});
  const connections = ref([]);
  const route = useRoute();
  const streams = ref({metrics: false, k8s: false});

  const pods = ref([]);
  const clusterPods = ref([]);

  const events = ref([]);
  const clusterEvents = ref([]);  

  const chart = ref();
  const chartState = ref('cpu');
  const initOptions = ref({ renderer: "svg" });

  const metrics = ref({
    cpu: [
      { 
        type:'pod', name:'cpu-usage', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'cores', name:'Usage', index: 1, colorDark: '#4992ff', colorLight: '#5470c6'}
      }
    ],
    memory: [
      {
        type:'pod', name:'mem-usage', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Usage', index: 1, colorDark: '#dd79ff', colorLight: '#ea7ccc'}
      },
    ],
    network: [
      {
        type:'pod', name:'net-recv', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Receive', colorDark: '#58d9f9', colorLight: '#73c0de'}
      }, 
      {
        type:'pod', name:'net-sent', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Transmit', colorDark: '#7cffb2', colorLight: '#91cc75'}
      }
    ],
    filesystem: [
      {
        type:'pod', name:'fs-reads', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Reads', colorDark: '#fddd60', colorLight: '#fac858'}
      }, 
      {
        type:'pod', name:'fs-writes', pods: '', namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Writes', colorDark: '#ff8a45', colorLight: '#fc8452'}
      }
    ]
  });

  let getCpuUsage = (row) => {
    if (metrics.value['cpu'][0].metrics.length < 1) return '-';
    let pod = row.metadata.name;

    let series = metrics.value['cpu'][0].metrics.filter(x => x.metric.pod == pod)[0]
    if (series === undefined) return '-';

    let usage = parseFloat(series.values.slice(-1)[0][1]);
    
    return usage.toFixed(3);
  }

  let getMemoryUsage = (row) => {
    if (metrics.value['memory'][0].metrics.length < 1) return '-';
    let pod = row.metadata.name;

    let series = metrics.value['memory'][0].metrics.filter(x => x.metric.pod == pod)[0]
    if (series === undefined) return '-';

    let usage = parseFloat(series.values.slice(-1)[0][1]);
    let unit = getUnitFromBytes(usage);
    return `${(usage / unit.magnitude).toFixed(1)} ${unit.suffix}`
  }

  const charts = ref({
    cpu: getSimpleChart(),
    memory: getSimpleChart(),
    network: getSimpleChart(),
    filesystem: getSimpleChart()
  });

  const sorting = ref([ {id:'name', sort:'asc'} ]);
  const columns = ref([
    { header: 'Name', id: 'name', classes: 'truncate grow shrink w-52', 
      accessor: row => row.metadata.name },
    { header: 'Node', id: 'node', classes: 'w-72', 
      accessor: row => row.spec.nodeName },
    { header: 'Containers', id: 'containers', classes: 'truncate w-32', canSort: false, 
      accessor: row => row.status.containerStatuses, formatter:'pod-lights' },
    { header: 'Cpu', id: 'cpu', classes: 'truncate w-24', 
      accessor: getCpuUsage },
    { header: 'Memory', id: 'memory', classes: 'truncate w-24', 
      accessor: getMemoryUsage },
    { header: 'Status', id: 'status', classes: 'w-[6rem]', canSort: false, 
      accessor: row => row.status.phase, formatter:'pod-status' }
  ]);
  
  let updateMetrics = async () => {
    if (props.config.metrics !== true || pods.value.length < 1) return;

    if (streams.value.metrics) return;
    //console.log("scheduling metrics updates");
    streamMetrics(metrics.value.cpu, updateCpu, connections.value, true);
    streamMetrics(metrics.value.memory, updateMemory, connections.value, true);
    streamMetrics(metrics.value.network, updateNetworking, connections.value, true);
    streamMetrics(metrics.value.filesystem, updateFilesystem, connections.value, true);
    streams.value.metrics = true;
  }

  let updateCpu = () => {
    if (!metrics.value.cpu) return;
    if (metrics.value.cpu[0].metrics.length < 1) return;

    var [data, max, unit] = getSumSeries(metrics.value.cpu);

    updateSimpleChart(charts.value.cpu, metrics.value.cpu, unit, isDark.value);
  };
  
  let updateMemory = () => {
    if (!metrics.value.memory) return;
    if (metrics.value.memory[0].metrics.length < 1) return;

    var [data, max, unit] = getSumSeries(metrics.value.memory);
    
    updateSimpleChart(charts.value.memory, metrics.value.memory, unit, isDark.value);
  };

  let updateNetworking = () => {
    if (!metrics.value.network) return;
    if (metrics.value.network[0].metrics.length < 1) return;

    var [data, max, unit] = getSumSeries(metrics.value.network);

    updateSimpleChart(charts.value.network, metrics.value.network, unit, isDark.value);
  }

  let updateFilesystem = () => {
    if (!metrics.value.filesystem) return;
    if (metrics.value.filesystem[0].metrics.length < 1) return;

    var [data, max, unit] = getSumSeries(metrics.value.filesystem);

    updateSimpleChart(charts.value.filesystem, metrics.value.filesystem, unit, isDark.value);
  }

  watch([chartState, pods, isDark], () => {
    updateCpu();
    updateMemory();
    updateNetworking();
    updateFilesystem();
  })

  let matchLabels = (labels, selector) => {
    let result = Object.keys(selector).every(x => labels[x] === selector[x])
    return result;
  }

  watch([clusterPods, item], () => {
    if (item.value?.spec?.selector?.matchLabels === undefined) return;

    let current = clusterPods.value.filter(x => matchLabels(x?.metadata?.labels, item.value?.spec?.selector?.matchLabels));
    let podsList = current.map(x => x.metadata.name).join('|');

    metrics.value['cpu'].forEach(x => x['pods'] = podsList);
    metrics.value['memory'].forEach(x => x['pods'] = podsList);
    metrics.value['network'].forEach(x => x['pods'] = podsList);
    metrics.value['filesystem'].forEach(x => x['pods'] = podsList);

    pods.value = current;

    updateMetrics();
  });

  watch(clusterEvents, () => {
    let name = route.params.name;
    events.value = clusterEvents.value.filter(x => x?.involvedObject?.name === name).sort(x => x.lastTimestamp).reverse();
  });
  
  onMounted(async () => {
    let name = route.params.name;
    let type = route.params.type;
    let namespace = route.params.namespace;
    
    let url = `/k8s/apis/apps/v1/namespaces/${namespace}/${type}s`;
    if (['cronjobs', 'jobs'].includes(type + 's')){
        url = `/k8s/apis/batch/v1/namespaces/${namespace}/${type}s`    
    }
    
    if (streams.value.k8s) return;
    streamResult(url, name, j => item.value = j, connections.value);
    streamResults(`/k8s/api/v1/namespaces/${namespace}/pods`, j => clusterPods.value = j, connections.value);
    streamResults(`/k8s/api/v1/namespaces/${namespace}/events`, j => clusterEvents.value = j, connections.value)
    streams.value.k8s = true;
  });
  
  onUnmounted(async () => {
    closeConnections(connections.value);
  });

  return { 
    pods, clusterPods, events, clusterEvents, sorting, columns, getCpuUsage, streams,
    item, connections, toLocal, toHuman,
    metrics, charts, chartState, initOptions, isDark,
    updateCpu, updateMemory, updateNetworking, updateFilesystem, updateMetrics
  }
}

components["workload-details"] = { template: "#workload-details", props: ['config', 'filters'], setup };    
routes.push({path:'/namespaces/:namespace/workloads/:name/:type', name:'workload-details', component: components["workload-details"]})    
</script>
