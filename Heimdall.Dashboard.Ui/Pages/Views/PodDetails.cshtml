<template id="pod-details">
  <div class="pl-2 pr-4 max-w-5xl mx-auto">
    
    <div class="flex mt-4 mb-6 text-xl justify-between items-center text-gray-500 dark:text-gray-300 font-light sans h-8">
      <div class="text-md truncate pe-2">
      <router-link :to="{ name: 'pods' }"
      class="hover:text-sky-500 dark:hover:text-blue-400"> Pod </router-link> / 
      <router-link :to="{ name: 'pods-redirect', params: {namespace: pod?.metadata?.namespace } }"
      class="hover:text-sky-500 dark:hover:text-blue-400"> {{pod?.metadata?.namespace }} </router-link> / 
      {{ pod?.metadata?.name }}
      </div>
      <div class="flex">
        <template v-if="config.canRestartPod && pod">
          <restart-pod :pod="pod"></restart-pod>  
        </template>
        <template v-if="pod?.spec?.containers.length == 1">
          <logs-btn :container="pod.spec.containers[0].name"></logs-btn>
        </template>
        <div v-else class="flex px-2 w-28"></div>
      </div>
    </div>
    
    <pod-charts :charts="charts" :config="config"></pod-charts>

    <pod-info :pod="pod" :plans="planSpec"></pod-info>

    <pod-containers :pod="pod"></pod-containers>

    <pod-events :events="events"></pod-events>

    <pod-volumes :pod="pod"></pod-volumes>

    <br/><br/><br/><br/>
    
  </div>
</template>

<script type="module">
import { useDark } from "@@vueuse/core";
import { useRoute, useRouter } from 'vue-router'
import { ref, watch, onMounted, onUnmounted } from 'vue'

let setup = (props, ctx) => {
  const isDark = useDark();
  const route = useRoute();
  const router = useRouter();
  const connections = ref([]);
  const streams = ref({metrics: false, k8s: false, spec: false});

  const pod = ref({});

  const events = ref([]);
  const clusterEvents = ref([]);  

  const chartState = ref('cpu');
  const limitState = ref(false);
  const initOptions = ref({ renderer: "svg" });
  
  const metrics = ref({
    cpu: [
      { 
        type:'pod', name:'cpu-usage', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'cores', name:'Usage', index: 1, colorDark: '#4992ff', colorLight: '#5470c6'}
      }
    ],
    memory: [
      {
        type:'pod', name:'mem-usage', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Usage', index: 1, colorDark: '#dd79ff', colorLight: '#ea7ccc'}
      },
    ],
    network: [
      {
        type:'pod', name:'net-recv', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Receive', colorDark: '#58d9f9', colorLight: '#73c0de'}
      }, 
      {
        type:'pod', name:'net-sent', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Transmit', colorDark: '#7cffb2', colorLight: '#91cc75'}
      }
    ],
    filesystem: [
      {
        type:'pod', name:'fs-reads', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Reads', colorDark: '#fddd60', colorLight: '#fac858'}
      }, 
      {
        type:'pod', name:'fs-writes', pods: route.params.name, namespace: route.params.namespace, 
        metrics: [], data: [], params: { unit: 'bytes', name:'Writes', colorDark: '#ff8a45', colorLight: '#fc8452'}
      }
    ]
  });
  
  const charts = ref({
    cpu: getSimpleChart(),
    memory: getSimpleChart(),
    network: getSimpleChart(),
    filesystem: getSimpleChart()
  });
  
  let updateMetrics = async () => {
    if (props.config.metrics !== true) return;

    if (streams.value.metrics) return;
    //console.log("scheduling metrics updates");
    streamMetrics(metrics.value.cpu, updateCpu, connections.value, false);
    streamMetrics(metrics.value.memory, updateMemory, connections.value, false);
    streamMetrics(metrics.value.network, updateNetworking, connections.value, false);
    streamMetrics(metrics.value.filesystem, updateFilesystem, connections.value, false);
    streams.value.metrics = true;
  }
  
  let updateCpu = () => {
    if (!metrics.value.cpu) return;
    if (metrics.value.cpu[0].metrics.length < 1) return;

    var [data, max, unit] = getDataSeries(metrics.value.cpu);

    let limit = 0;
    if (limitState.value){    
      let containers = pod.value?.spec?.containers?.map(x => cpuUnitsToNumber(x.resources?.limits?.cpu)) ?? [];
      limit = containers.reduce((a, b) => a + b, 0);
    }

    updateSimpleChart(charts.value.cpu, metrics.value.cpu, unit, isDark.value, limit);
  };
  
  let updateMemory = () => {
    if (!metrics.value.memory) return;
    if (metrics.value.memory[0].metrics.length < 1) return;

    var [data, max, unit] = getDataSeries(metrics.value.memory);
    
    let limit = 0;
    if (limitState.value){    
      let containers = pod.value?.spec?.containers?.map(x => memoryUnitToBytes(x.resources?.limits?.memory)) ?? [];
      limit = containers.reduce((a, b) => a + b, 0);
    }

    updateSimpleChart(charts.value.memory, metrics.value.memory, unit, isDark.value, limit);
  };

  let updateNetworking = () => {
    if (!metrics.value.network) return;
    if (metrics.value.network[0].metrics.length < 1) return;

    var [data, max, unit] = getDataSeries(metrics.value.network);

    updateSimpleChart(charts.value.network, metrics.value.network, unit, isDark.value);
  }

  let updateFilesystem = () => {
    if (!metrics.value.filesystem) return;
    if (metrics.value.filesystem[0].metrics.length < 1) return;

    var [data, max, unit] = getDataSeries(metrics.value.filesystem);

    updateSimpleChart(charts.value.filesystem, metrics.value.filesystem, unit, isDark.value);
  }
  
  watch(() => props.config.metrics, () => {
    updateMetrics();
  });

  watch(clusterEvents, () => {
    let name = route.params.name;
    events.value = clusterEvents.value.filter(x => x?.involvedObject?.name === name).sort(x => x.lastTimestamp).reverse();
  });
  });
  
  watch([limitState, chartState, isDark], () => {
    updateCpu();
    updateMemory();
    updateNetworking();
    updateFilesystem();
  })

  onMounted(async () => {
    if (route.name === 'pod-logs-redirect'){
      fetch(`/k8s/api/v1/namespaces/${route.params.namespace}/pods/${route.params.name}`)
        .then(r => r.json())
        .then(pod => {
            let container = pod.spec.containers[0].name;
            router.push({ name: 'pod-logs', params: { namespace: route.params.namespace, name: route.params.name, container: container }, replace: true})
        });
      return;
    }
    
    let namespace = route.params.namespace;

    updateMetrics();
    
    if (!streams.value.k8s){
      streamResult(`/k8s/api/v1/namespaces/${namespace}/pods`, route.params.name, j => pod.value = j, connections.value);
      streamResults(`/k8s/api/v1/namespaces/${namespace}/events`, j => clusterEvents.value = j, connections.value)
      streams.value.k8s = true;
    }
  });

  onUnmounted(async () => {
    closeConnections(connections.value);
  });
  
  return {
      connections, isDark, events, clusterEvents, pod, streams,
      metrics, planSpec, charts, chartState, initOptions, limitState, 
      updateCpu, updateMemory, updateNetworking, updateFilesystem, updateMetrics, updatePlanSpecMetrics, updatePlanSpec
  }
}

components["pod-details"] = {template: "#pod-details", props: ['config', 'filters'], setup};
routes.push({path:'/namespaces/:namespace/pods/:name/logs', name:'pod-logs-redirect', component: components["pod-details"]})
routes.push({path:'/namespaces/:namespace/pods/:name/details', name:'pod-details', component: components["pod-details"]})
</script>